#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX_PRODS 50
#define MAX_SYMBOLS 50
#define MAX_RHS 20
#define MAX_LEN 100

typedef struct {
    char lhs;
    char rhs[MAX_RHS][MAX_LEN];
    int rhs_count;
} Production;

Production prods[MAX_PRODS];
int prod_count;

char first[MAX_SYMBOLS][MAX_LEN];
char follow[MAX_SYMBOLS][MAX_LEN];
int first_count[MAX_SYMBOLS];
int follow_count[MAX_SYMBOLS];

char non_terminals[MAX_SYMBOLS];
int nt_count = 0;

int is_non_terminal(char c) {
    return (c >= 'A' && c <= 'Z');
}

int get_non_terminal_index(char c) {
    for (int i = 0; i < nt_count; i++) {
        if (non_terminals[i] == c)
            return i;
    }
    return -1;
}

int contains(char *arr, int size, char c) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == c) return 1;
    }
    return 0;
}

void add_non_terminal(char c) {
    if (!contains(non_terminals, nt_count, c)) {
        non_terminals[nt_count++] = c;
    }
}

void add_to_set(char *set, int *count, char c) {
    if (!contains(set, *count, c)) {
        set[(*count)++] = c;
        set[*count] = '\0';
    }
}

int is_in_string(char *str, char c) {
    for (int i=0; i<(int)strlen(str); i++) {
        if (str[i] == c) return 1;
    }
    return 0;
}

void compute_first();
void compute_follow();

int main() {
    printf("Enter number of productions: ");
    scanf("%d", &prod_count);
    getchar();

    for (int i = 0; i < prod_count; i++) {
        char line[200];
        printf("Enter production %d (e.g. A=Ab|c): ", i + 1);
        fgets(line, sizeof(line), stdin);

        char *pos = strchr(line, '=');
        if (!pos) {
            printf("Invalid format, try again.\n");
            i--;
            continue;
        }

        prods[i].lhs = line[0];
        add_non_terminal(prods[i].lhs);
        prods[i].rhs_count = 0;

        char *rhs = pos + 1;
        char *newline = strchr(rhs, '\n');
        if (newline) *newline = '\0';

        char *token = strtok(rhs, "|");
        while (token != NULL) {
            if (strlen(token) == 0) {
                printf("Empty production part not allowed.\n");
                i--;
                break;
            }
            strcpy(prods[i].rhs[prods[i].rhs_count++], token);
            token = strtok(NULL, "|");
        }
    }

    for (int i = 0; i < nt_count; i++) {
        first_count[i] = 0;
        follow_count[i] = 0;
        first[i][0] = '\0';
        follow[i][0] = '\0';
    }

    compute_first();

    follow_count[0] = 0;
    add_to_set(follow[0], &follow_count[0], '$');

    compute_follow();

    printf("\nFIRST sets:\n");
    for (int i = 0; i < nt_count; i++) {
        printf("FIRST(%c) = { ", non_terminals[i]);
        for (int j = 0; j < first_count[i]; j++) {
            printf("%c ", first[i][j]);
        }
        printf("}\n");
    }

    printf("\nFOLLOW sets:\n");
    for (int i = 0; i < nt_count; i++) {
        printf("FOLLOW(%c) = { ", non_terminals[i]);
        for (int j = 0; j < follow_count[i]; j++) {
            printf("%c ", follow[i][j]);
        }
        printf("}\n");
    }

    return 0;
}

void compute_first() {
    int changed;
    do {
        changed = 0;
        for (int i = 0; i < prod_count; i++) {
            int lhs_index = get_non_terminal_index(prods[i].lhs);
            for (int j = 0; j < prods[i].rhs_count; j++) {
                char *rhs = prods[i].rhs[j];
                if (rhs[0] == '#') {
                    if (!is_in_string(first[lhs_index], '#')) {
                        add_to_set(first[lhs_index], &first_count[lhs_index], '#');
                        changed = 1;
                    }
                } else {
                    int k = 0;
                    int epsilon_in_prev = 1;
                    while (rhs[k] != '\0' && epsilon_in_prev) {
                        epsilon_in_prev = 0;
                        char c = rhs[k];

                        if (!is_non_terminal(c)) {
                            if (!is_in_string(first[lhs_index], c)) {
                                add_to_set(first[lhs_index], &first_count[lhs_index], c);
                                changed = 1;
                            }
                            break;
                        } else {
                            int c_index = get_non_terminal_index(c);
                            for (int x = 0; x < first_count[c_index]; x++) {
                                if (first[c_index][x] != '#' && !is_in_string(first[lhs_index], first[c_index][x])) {
                                    add_to_set(first[lhs_index], &first_count[lhs_index], first[c_index][x]);
                                    changed = 1;
                                }
                            }
                            if (is_in_string(first[c_index], '#')) {
                                epsilon_in_prev = 1;
                            }
                        }
                        k++;
                    }
                    if (epsilon_in_prev) {
                        if (!is_in_string(first[lhs_index], '#')) {
                            add_to_set(first[lhs_index], &first_count[lhs_index], '#');
                            changed = 1;
                        }
                    }
                }
            }
        }
    } while (changed);
}

void compute_follow() {
    int changed;
    do {
        changed = 0;
        for (int i = 0; i < prod_count; i++) {
            char A = prods[i].lhs;
            int A_index = get_non_terminal_index(A);

            for (int j = 0; j < prods[i].rhs_count; j++) {
                char *rhs = prods[i].rhs[j];
                int len = strlen(rhs);

                for (int k = 0; k < len; k++) {
                    char B = rhs[k];
                    if (is_non_terminal(B)) {
                        int B_index = get_non_terminal_index(B);
                        int epsilon_in_next = 1;

                        int l = k + 1;
                        while (l < len && epsilon_in_next) {
                            epsilon_in_next = 0;
                            char c = rhs[l];

                            if (!is_non_terminal(c)) {
                                if (!is_in_string(follow[B_index], c)) {
                                    add_to_set(follow[B_index], &follow_count[B_index], c);
                                    changed = 1;
                                }
                                break;
                            } else {
                                int c_index = get_non_terminal_index(c);
                                for (int x = 0; x < first_count[c_index]; x++) {
                                    if (first[c_index][x] != '#' && !is_in_string(follow[B_index], first[c_index][x])) {
                                        add_to_set(follow[B_index], &follow_count[B_index], first[c_index][x]);
                                        changed = 1;
                                    }
                                }
                                if (is_in_string(first[c_index], '#')) {
                                    epsilon_in_next = 1;
                                } else {
                                    break;
                                }
                            }
                            l++;
                        }

                        if (l == len && epsilon_in_next) {
                            for (int x = 0; x < follow_count[A_index]; x++) {
                                if (!is_in_string(follow[B_index], follow[A_index][x])) {
                                    add_to_set(follow[B_index], &follow_count[B_index], follow[A_index][x]);
                                    changed = 1;
                                }
                            }
                        }
                    }
                }
            }
        }
    } while (changed);
}
